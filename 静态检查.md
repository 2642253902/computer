# 阅读 1：静态检查

#### 今天课程的目标

今天课程有两个主题：

-   静态类型检查
- 好的软件的三大特性

##    hailstone sequence（ hailstone 数列 ）

作为一个运行示例，我们将探讨 hailstone 数列，其定义如下。从数字 n 开始，如果 n 是偶数，则序列中的下一个数字是 n/2；如果 n 是奇数，则序列中的下一个数字是 3n+1。当序列达到 1 时结束。这里有一些例子：

```
2, 1
3, 10, 5, 16, 8, 4, 2, 1
4, 2, 1
2ⁿ, 2ⁿ-1 , ... , 4, 2, 1
5, 16, 8, 4, 2, 1
7, 22, 11, 34, 17, 52, 6, 13, 40, ...? (where does this stop?)
```

由于奇数规则，序列可能会上下波动，然后减少到 1。人们猜想所有的 hailstone 最终都会落地——也就是说，对于所有起始的 n，hailstone 数列都会达到 1——但这仍然是一个悬而未决的问题。为什么称为 hailstone 数列？因为冰雹在云中通过上下波动形成，直到它们最终积累足够的重量落到地面。

##   计算 hailstones

这里有一些用于计算并打印某个起始数 n 的 hailstone 数列的代码。我们将用 Java 和 Python 并列编写，以便比较：

```java
// Java
int n = 3;
while (n != 1) {
    System.out.println(n);
    if (n % 2 == 0) {
        n = n / 2;
    } else {
        n = 3 * n + 1;
    }
}
System.out.println(n);
```

```python
# Python
n = 3
while n != 1:
    print n
    if n % 2 == 0:
        n = n / 2
    else:
        n = 3 * n + 1


print n
```

这里有几个值得注意的地方：

- Java 中表达式和语句的基本语义与 Python 非常相似：例如 `while` 和 `if` 的行为相同。
- Java 在语句的末尾需要分号。额外的标点符号可能会带来麻烦，但它也让你在组织代码时有更多的自由——你可以将一个语句拆分成多行以提高可读性。
- Java 要求在 `if` 和 `while` 的条件周围使用括号。
- Java 要求在代码块周围使用大括号，而不是缩进。即使 Java 不会关注你的额外空格，你也应该缩进代码块。编程是一种交流形式，你不仅是在与编译器交流，也是在与人交流。人类需要这种缩进。我们稍后会回到这一点。

##   类型

Python 和 Java 代码中最重要的语义差异在于变量 `n` 的声明，它指定了其类型： `int` 。

类型是一组值以及可以在这些值上执行的操作。

Java 有几种基本类型，其中包括：

- `int` （用于整数，如 5 和 -200，但仅限于 ± 2^31 的范围，或大致 ± 20 亿）
- `long` (用于较大的整数，范围在 ±2^63)
- `boolean` (用于 true 或 false)
- `double` (用于浮点数，它们表示实数的一个子集)
- `char` (用于单个字符，如 `'A'` 和 `'$'` )

Java 也有对象类型，例如：

- `String` 表示一个字符序列，类似于 Python 字符串。
- `BigInteger` 表示任意大小的整数，因此它类似于 Python 整数。

按照 Java 的惯例，原始类型是全小写的，而对象类型以大写字母开头。

操作是接受输入并产生输出（有时还会改变自身值）的函数。操作的语法各不相同，但无论其写法如何，我们仍然将其视为函数。以下是 Python 或 Java 中操作的三种不同语法：

- 作为中缀、前缀或后缀运算符。例如， `a + b` 调用操作 `+ : int × int → int` 。
  `+`：操作名称
  `int × int`：表示接受两个整数作为输入（× 表示笛卡尔积）
  `→ int`：表示返回一个整数结果
  
- 作为对象的方法。例如， `bigint1.add(bigint2)` 调用操作 `add: BigInteger × BigInteger → BigInteger` 。
  `BigInteger × BigInteger`：输入类型
    第一个参数：隐式的 `this` 对象（`bigint1`）
    第二个参数：显式参数（`bigint2`）
  `→ BigInteger`：输出类型（返回新的大整数对象）
  
- 作为函数。例如， `Math.sin(theta)` 调用操作 `sin: double → double` 。这里， `Math` 不是对象。它是包含 `sin` 函数的类。
  `sin`：操作名称（函数标识符）
  `double`：输入类型（单个双精度浮点数）
  `→ double`：输出类型（返回双精度结果）
  
对比 Java 的 `str.length()` 与 Python 的 `len(str)` 。这两种语言中的操作是相同的——一个接受字符串并返回其长度的函数——但它们只是使用了不同的语法。

某些操作在意义上是重载的，即同一个操作名称用于不同的类型。Java 中的算术运算符 `+` 、 `-` 、 `*` 、 `/` 对数值原始类型进行了大量重载。方法也可以重载。大多数编程语言都具有一定的重载功能。

##   静态类型

Java 是一种静态类型语言。所有变量的类型在编译时（程序运行之前）都是已知的，因此编译器可以推断出所有表达式的类型。如果 `a` 和 `b` 被声明为 `int` 类型，那么编译器会得出 `a+b` 也是 `int` 的结论。实际上，Eclipse 环境在您编写代码时会进行这种操作，因此您在键入代码时就能发现许多错误。

在动态类型语言（如 Python）中，这种检查被推迟到运行时（程序运行时）。

静态类型是一种静态检查，意味着在编译时检查错误。错误是编程的祸害。本课程中的许多思想都旨在从你的代码中消除错误，而静态检查是我们看到的第一种这种思想。静态类型可以防止大量错误感染你的程序：精确地说，是由将操作应用于错误类型的参数引起的错误。如果你写了一行有问题的代码，如：

```
   "5" * "6"
```

试图将两个字符串相乘，那么静态类型会在你仍然编程时捕获这个错误，而不是等到执行时遇到这一行。

## 静态检查、动态检查、无检查

思考语言可以提供的三种自动检查方式很有用：

- 静态检查：在程序运行之前自动发现错误。
- 动态检查：在代码执行时自动发现错误。
- 无检查：语言完全无法帮助你发现错误。你必须自己留意，或者最终得到错误的结果。

毋庸置疑，静态捕获错误比动态捕获错误更好，而动态捕获错误又比完全不捕获错误更好。

以下是一些关于在各个时间点可以预期捕获哪些错误的经验法则。

静态检查可以捕获：

- 语法错误，例如多余的标点符号或无意义的单词。即使是动态类型的语言（如 Python）也会进行这种静态检查。如果你的 Python 程序存在缩进错误，你会在程序开始运行之前发现它。
- 错误的名称，例如 `Math.sine(2)` 。(正确的名称是 `sin` 。)
- 参数数量错误，例如 `Math.sin(30, 20)` 。
- 参数类型错误，例如 `Math.sin("30")` 。
- 返回类型错误，例如 `return "30";` ，而该函数声明应返回 `int` 。

动态检查可以捕获：

- 非法的参数值。例如，整数表达式 `x/y` 只有在 `y` 实际为零时才是错误的；否则它是有效的。因此，在这个表达式中，除以零不是静态错误，而是动态错误。
- 无法表示的返回值，即当特定的返回值无法在类型中表示时。
- 超出范围的索引，例如在字符串上使用负数或过大的索引。
- 在 `null` 对象引用上调用方法（ `null` 类似于 Python 的 `None` ）。

静态检查通常与类型有关，错误与变量具体具有的值无关。类型是一组值。静态类型确保变量将具有该集合中的某个值，但我们直到运行时才知道它具体具有哪个值。因此，如果错误仅由特定值引起，例如除零错误或索引越界错误，那么编译器不会对此发出静态错误。

相比之下，动态检查通常与特定值引起的错误有关。

## 惊人：原始类型不是真正的数字

Java 中的一个陷阱——以及其他许多编程语言也是如此——是其原始数值类型存在一些特殊情况，这些情况的行为与我们所熟悉的整数和实数不同。因此，一些本应动态检查的错误根本不会被检查。以下是这些陷阱：

- 整数除法。 `5/2` 不会返回一个分数，它返回一个截断的整数。所以这是一个例子，我们原本希望这是一个动态错误（因为分数不能表示为整数），但经常会产生错误的结果。
    
- 整数溢出。 `int` 和 `long` 类型实际上是整数的有限集合，具有最大值和最小值。当你进行一个结果的正负超出该有限范围的计算时会发生什么？计算会默默地溢出（回绕），并返回一个合法范围内的整数，但不是正确的结果。
    
- `float` 和 `double` 中的特殊值。 `float` 和 `double` 类型有几个不是实数的特殊值： `NaN` （表示“不是数字”）， `POSITIVE_INFINITY` 和 `NEGATIVE_INFINITY` 。因此，你期望会产生动态错误的操作，如除以零或对负数取平方根，反而会产生这些特殊值之一。如果你继续用这个值计算，最终结果会出错。
    

##   数组与集合

让我们改变我们的 hailstone 计算方式，使其将序列存储在数据结构中，而不是仅仅打印出来。Java 有两种类似列表的类型我们可以使用：数组和 Lists。

数组是另一个类型 T 的固定长度序列。例如，以下是声明数组变量并构造一个数组值来赋给它的方法：

```
  int[] a = new int[100];
```

`int[]` 数组类型包括所有可能的数组值，但一旦创建，特定的数组值永远无法改变其长度。数组类型的操作包括：

-   索引： `a[2]`
-   赋值： `a[2]=0`
- 长度： `a.length` （注意：这与 `String.length()` – `a.length` 的语法不同—— `a.length` 不是方法调用，所以后面不加括号）

这里是一个使用数组的 hailstone 代码示例。我们首先构建数组，然后使用索引变量 `i` 遍历数组，在生成序列的同时存储值。

```
int[] a = new int[100];  // <==== DANGER WILL ROBINSON
int i = 0;
int n = 3;
while (n != 1) {
    a[i] = n;
    i++;  // very common shorthand for i=i+1
    if (n % 2 == 0) {
        n = n / 2;
    } else {
        n = 3 * n + 1;
    }
}
a[i] = n;
i++;
```

在这个方法中，应该立刻察觉到有问题。那个神奇的数字 100 是什么？如果我们尝试一个结果为非常长的 hailstone 序列的 n 会发生什么？它不会适合在长度为 100 的数组中。我们有一个 bug。Java 会静态捕获这个 bug，动态捕获，还是根本不会捕获？顺便说一句，像这样的 bug——固定长度数组的溢出，这些 bug 在像 C 和 C++这样不进行自动运行时数组访问检查的不太安全的语言中很常见——已经导致了大量的网络安全漏洞和互联网蠕虫。

我们不用固定长度的数组，而是使用 `List` 类型。列表是另一种类型 `T` 的可变长度序列。下面是如何声明一个 `List` 变量并创建一个列表值的示例：

```
  List<Integer> list = new ArrayList<Integer>();
```

这里有一些它的操作：

-   索引： `list.get(2)`
-   赋值： `list.set(2, 0)`
-   长度： `list.size()`

请注意 `List` 是一个接口，一种不能通过 new 直接构造的类型，而是指定了 List 必须提供的操作。我们将在未来的抽象数据类型课程中讨论这个概念。 `ArrayList` 是一个类，一种提供了这些操作的具象类型。 `ArrayList` 不是 List 类型的唯一实现，尽管它是使用最广泛的实现。 `LinkedList` 是另一个。在 Java API 文档中查看它们，您可以通过在网络上搜索“Java 8 API”找到该文档。熟悉 Java API 文档，它们是您的朋友。（“API”意为“应用程序接口”，通常用作“库”的同义词。）

请注意，我们写了 `List<Integer>` 而不是 `List<int>` 。不幸的是，我们不能直接类比 `int[]` 来写 `List<int>` 。列表只知道如何处理对象类型，而不是基本类型。在 Java 中，每个基本类型（通常用小写字母书写并缩写，如 `int` ）都有一个等价的对象类型（通常用大写字母书写并完整拼写，如 `Integer` ）。Java 要求我们在用尖括号参数化类型时使用这些对象类型的等价物。但在其他上下文中，Java 会自动在 `int` 和 `Integer` 之间转换，因此我们可以写 `Integer i = 5` 而不会出现类型错误。

这是用列表编写的 hailstone 代码：

```java
List<Integer> list = new ArrayList<Integer>();
int n = 3;
while (n != 1) {
    list.add(n);
    if (n % 2 == 0) {
        n = n / 2;
    } else {
        n = 3 * n + 1;
    }
}
list.add(n);
```

不仅更简单，也更安全，因为 List 会自动扩展以容纳你添加的尽可能多的数字（当然，直到内存耗尽为止）。

##   迭代

一个 for 循环遍历数组或列表的元素，就像在 Python 中一样，尽管语法看起来有点不同。例如：

```
// find the maximum point of a hailstone sequence stored in list
int max = 0;
for (int x : list) {
    max = Math.max(x, max);
}
```

你可以遍历数组以及列表。如果将列表替换为数组，相同的代码也会工作。

`Math.max()` 是 Java API 中一个方便的函数。 `Math` 类充满了像这样的有用函数——在网络上搜索“java 8 Math”可以找到它的文档。

##   方法

在 Java 中，语句通常必须位于方法内部，并且每个方法都必须位于类中，因此我们 hailstone 程序的最简单写法如下：

```java
public class Hailstone {
  /**
   * Compute a hailstone sequence.
   * @param n  Starting number for sequence.  Assumes n > 0.
   * @return hailstone sequence starting with n and ending with 1.
   */
  public static List<Integer> hailstoneSequence(int n) {
    List<Integer> list = new ArrayList<Integer>();
    while (n != 1) {
        list.add(n);
        if (n % 2 == 0) {
            n = n / 2;
        } else {
            n = 3 * n + 1;
        }
    }
    list.add(n);
    return list;
  }
}
```

让我们解释一下这里的一些新事物。

`public` 表示程序中任何地方的代码都可以引用该类或方法。其他访问修饰符（如 private）用于提高程序安全性，并确保不可变类型的不变性。我们将在接下来的课程中更多地讨论它们。

`static` 表示该方法不接受 this 参数。但静态方法没有这个隐式参数 - 它们就像普通函数一样运行。——在 Java 中，this是隐式的，你永远不会将其作为方法参数看到。静态方法不能在对象上调用。与 `List` `add()` 方法或 `String` `length()` 方法形成对比，例如，这些方法需要先提供对象。调用静态方法的正确方式是使用类名而不是对象引用：

```java
  Hailstone.hailstoneSequence(83)
```

同样要注意方法前的注释，因为它非常重要。这条注释是对方法的规范，描述了操作的输入和输出。规范应该简洁、清晰、精确。注释提供了方法类型中已经不明显的信息。例如，它没有说明 `n` 是一个整数，因为紧随其下的 `int n` 声明已经说明了这一点。但它确实说明了 `n` 必须是正数，这是类型声明所没有捕捉到的，但对于调用者来说非常重要。

在接下来的几节课中，我们将更多地讨论如何编写良好的规范，但你必须从现在开始就开始阅读它们并使用它们。

## 可变值与变量重新赋值

下一篇文章将介绍快照图，以帮助我们可视化改变变量与改变值的区别。当你将值赋给变量时，你正在改变变量箭头指向的位置。你可以将其指向不同的值。

当你将值赋给可变量的内容时——例如数组或列表——你正在改变该值内部的引用。

变化是一种必要的邪恶。好的程序员避免变化的事物，因为它们可能会意外地改变。

不可变性（防止变化）是本课程的一个主要设计原则。不可变类型是指一旦创建后其值就永远不会改变的类型。（至少不是以对外部世界可见的方式——在这方面有一些微妙之处，我们将在未来的不可变性课程中更多地讨论。）我们讨论过的类型中哪些是不可变的，哪些是可变的？

Java 还为我们提供了不可变引用：一旦分配后就永远不会重新分配的变量。要使引用不可变，请使用 final 关键字声明它：

```
  final int n = 5;
```

如果 Java 编译器不确信您的最终变量在运行时只会被分配一次，那么它将产生编译错误。因此，final 为不可变引用提供了静态检查。

使用 final 关键字声明方法参数以及尽可能多的局部变量是一种良好的实践。像变量类型一样，这些声明也是重要的文档，对代码阅读者有用，并且会被编译器进行静态检查。

在我们的 hailstoneSequence 方法中有两个变量：我们可以将它们声明为 final，还是不能？

```
  public static List<Integer> hailstoneSequence(final int n) { 
    final List<Integer> list = new ArrayList<Integer>();
```

##   记录假设

记录变量的类型是一种假设的说明：例如，该变量将始终引用一个整数。Java 实际上在编译时检查这一假设，并保证你的程序中没有违反这一假设的地方。

将变量声明为 final 也是一种文档形式，声明该变量在初始赋值后永远不会改变。Java 也会静态地检查这一点。

我们记录了另一个假设，即 Java（不幸的是）不会自动检查：n 必须是正数。

我们为什么需要写下我们的假设？因为编程充满了假设，如果我们不把它们写下来，我们会忘记它们，而且以后需要阅读或修改我们程序的其他人也不会知道它们。他们只能猜测。

编写程序时必须有两个目标：

- 与计算机通信。首先说服编译器你的程序是合理的——语法正确且类型正确。然后确保逻辑正确，以便在运行时得到正确的结果。
- 与其他人通信。使程序易于理解，以便当有人需要修复它、改进它或在将来适应它时，他们能够做到。

##   黑客攻击与工程

我们在这门课中写了一些“hacky”的代码。黑客行为通常表现为不受约束的乐观主义：

- 糟糕：在测试任何代码之前就编写大量代码
- 糟糕：将所有细节都记在脑中，假设自己永远不会忘记，而不是将它们写进代码中
- 糟糕：假设错误不存在或容易发现和修复

但软件工程不是黑客行为。工程师是悲观主义者：

- 好：一次写一点，边写边测试。在未来的课程中，我们将讨论先测试编程。
- 好：记录你的代码所依赖的假设
- 好的：防御你的代码免受愚蠢的影响——尤其是你自己的愚蠢！静态检查能帮助你做到这一点。

## 6.005 的目标

本课程的主要目标是学习如何生产出以下特性的软件：

- 无 bug 的安全性。正确性（当前的正确行为），以及防御性（未来的正确行为）。
- 易于理解。需要与未来的程序员沟通，让他们理解并对其进行修改（修复错误或添加新功能）。未来的程序员可能就是你，几个月或几年后。如果你不写下来，你会惊讶于自己忘记了多少，以及良好的设计如何帮助你未来的自己。
- 准备好变更。软件总是在变化。有些设计使变更变得容易；而另一些则需要丢弃大量代码并重写。

软件还有其他重要的属性（如性能、可用性、安全性），它们可能与这三者进行权衡。但在 6.005 课程中，这三者是我们在构建软件时首先考虑的。值得我们考虑本课程中学习的每一种语言特性、每一种编程实践、每一种设计模式，并理解它们与三大要素的关系。

## 为什么我们在这门课程中使用 Java

既然你已经学过 6.01，我们假设你对 Python 很熟悉。那么为什么我们在这门课中不使用 Python 呢？为什么我们在 6.005 中使用 Java？

第一个原因是安全性。Java 具有静态检查（主要是类型检查，但也包括其他类型的静态检查，比如确保你的代码从声明要返回值的方法中返回值）。在这门课中我们学习软件工程，而避免 bug 是这种方法的核心理念。Java 将安全性提升到了 11 级，这使得它成为学习良好软件工程实践的良好语言。当然，在像 Python 这样的动态语言中编写安全代码是可能的，但如果你在一个安全、静态检查的语言中学习如何做，你就更容易理解需要做什么。

普遍性是另一个原因。Java 在研究、教育和工业领域被广泛使用。Java 可以在许多平台上运行，而不仅仅是 Windows/Mac/Linux。Java 可用于 Web 编程（既可在服务器端也可在客户端），原生 Android 编程也是用 Java 完成的。尽管其他编程语言更适合教学编程（比如 Scheme 和 ML），但遗憾的是这些语言在现实世界中的普及度并不高。你的简历上写 Java 将被视为一项有市场价值的技能。但别误会：这门课程能让你获得的真实技能并非特定于 Java，而是可以迁移到任何你可能会编程的语言。这门课程最重要的教训将超越语言潮流：安全性、清晰性、抽象化、工程直觉。

无论如何，一个好程序员必须是多语言的。编程语言是工具，你必须为工作选择合适的工具。在你完成 MIT 学业之前，你肯定会学到其他编程语言（JavaScript、C/C++、Scheme 或 Ruby 或 ML 或 Haskell），所以我们现在就开始学习第二门语言。

由于 Java 的普遍性，它拥有大量有趣且实用的库（包括其庞大的内置库以及其他网络上的库），以及出色的免费开发工具（如 Eclipse 的 IDE、编辑器、编译器、测试框架、分析器、代码覆盖率工具和样式检查器）。即使 Python 在其生态系统的丰富性方面仍然落后于 Java。

使用 Java 有一些令人遗憾的原因。它冗长，这使得在黑板上写示例变得困难。它庞大，多年来积累了许多功能。它内部不一致（例如， `final` 关键字在不同的上下文中含义不同，而 Java 中的 `static` 关键字与静态检查无关）。它承载着像 C/C++ 这样旧语言的包袱（原始类型和 `switch` 语句就是很好的例子）。它没有像 Python 那样的解释器，你可以在其中通过玩弄小块代码来学习。

但总的来说，Java 是目前学习如何编写无 bug、易于理解且易于变更的代码的一个合理选择。这就是我们的目标。

##   摘要

我们今天介绍的主要思想是静态检查。以下是这一思想与课程目标的关系：

- 无 bug 安全。静态检查通过在运行时之前捕获类型错误和其他 bug 来帮助提高安全性。
    
- 易于理解。它有助于理解，因为类型在代码中明确声明。
    
- 准备好变更。静态检查通过识别需要同时更改的其他位置，使代码变更更加容易。例如，当你更改变量的名称或类型时，编译器会立即在所有使用该变量的位置显示错误，提醒你也要更新它们。