| 读数                                                                                                        | 主题                                                                                                                                                           |
| --------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [[1：静态检查Static Checking]]                                                                                 | - 类型<br>- 静态检查与动态检查<br>- 数组和集合<br>- 迭 代<br>- 方法<br>- 改变变量与重新分配变量<br>- 记录假设                                                                                   |
| 2：基础Java                                                                                                  | - 快照图<br>- Java 集合<br>- Java API 文档                                                                                                                          |
| 3：测试                                                                                                      | - 验证<br>- 测试优先编程<br>- 通过分区选择测试用例<br>- 黑盒和白盒测试<br>- 记录测试策略<br>- 覆盖<br>- 单元测试和存根<br>- 自动化测试和回归测试                                                               |
| [4：代码审查]                                                                                                  | - 不要重复自己<br>- 需要时的评论<br>- 快速失败<br>- 避免幻数<br>- 每个变量一个用途<br>- 使用好名字<br>- 使用空格帮助读者<br>- 不要使用全局变量<br>- 方法应该返回结果，而不是打印它们                                          |
| [5：版本控制](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/05-version-control/)                             | - 发明版本控制<br>- Git：复制、提交、拉取、推送、合并                                                                                                                             |
| [6：规格](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/06-specifications/)                                | - 为什么选择规格？<br>- 行为等效性<br>- 规格结构<br>- 空引用<br>- 规范可能谈论什么<br>- 测试和规格<br>- 变异方法规范<br>- 信号错误的例外<br>- 特殊结果的例外情况<br>- 已检查和未检查的异常<br>- 可投掷层级<br>- 异常设计注意事项<br>- 滥用例外 |
| [7：设计规格](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/07-designing-specs/)                             | - 确定性与未确定的规格<br>- 声明性规范与作规范<br>- 更强与更弱的规格<br>- 图表规格<br>- 设计良好的规格<br>- 先决条件还是后置条件？<br>- 关于访问控制<br>- 关于静态方法与实例方法                                               |
| [8：避免调试](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/08-avoiding-debugging/)                          | - 第一防御：让错误变得不可能<br>- 第二道防御：本地化错误<br>- 断言<br>- 断言的内容<br>- 什么不该断言<br>- 增量开发<br>- 模块化和封装                                                                        |
| [9：可变性和不变性](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/09-immutability/)                             | - 易变性<br>- 突变风险<br>- 混叠是使突变有风险的原因<br>- 变异方法规范<br>- 迭代数组和列表<br>- 突变破坏迭代器<br>- 突变和契约<br>- 有用的实现类型                                                              |
| [10：递归](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/10-recursion/)                                    | - 为问题选择正确的分解<br>- 递归实现的结构<br>- 辅助方法<br>- 选择正确的递归子问题<br>- 递归问题与递归数据<br>- 可重入代码<br>- 何时使用递归而不是迭代<br>- 递归实现中的常见错误                                               |
| [11：调试](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/11-debugging/)                                    | - 重现错误<br>- 了解错误的位置和原因<br>- 修复错误                                                                                                                             |
| [12：抽象数据类型](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/12-abstract-data-types/)                      | - 抽象的含义<br>- 分类类型和作<br>- 设计抽象类型<br>- 代表独立性<br>- 在 Java 中实现 ADT 概念<br>- 测试和抽象数据类型                                                                             |
| [13：抽象函数和代表不变量](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/13-abstraction-functions-rep-invariants/) | - 不变量<br>- 代表不变和抽象函数<br>- 记录 AF、RI 和代表暴露的安全性<br>- ADT 不变量替换前置条件                                                                                              |
| [14：接口](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/14-interfaces/)                                   | - 接口<br>- 亚<br>- 示例：MyString<br>- 示例：设置<br>- 通用接口<br>- 为什么选择接口？<br>- 在 Java 中实现 ADT 概念，第二部分                                                                  |
| [15：平等](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/15-equality/)                                     | - 看待平等的三种方式<br>- == 与 equals（）<br>- 不可变类型的相等性<br>- 对象契约<br>- 可变类型的相等<br>- Equals（） 和 hashCode（） 的最终规则                                                        |
| [16：递归数据类型](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/16-recursive-data-types/)                     | - 递归函数<br>- 不可变列表<br>- 递归数据类型定义<br>- 递归数据类型的函数<br>- 调整代表<br>- 空与空<br>- 声明类型与实际类型<br>- 示例：布尔公式<br>- 使用 ADT 编写程序<br>- 使用 ADT 编程的配方<br>- 示例：矩阵乘法                |
| [17：正则表达式和语法](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/17-regex-grammars/)                         | - 语法<br>- 正则表达式                                                                                                                                              |
| [18：解析器生成器](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/18-parser-generators/)                        | - 解析器生成器<br>- Antlr 语法<br>- 生成解析器<br>- 调用解析器<br>- 遍历解析树<br>- 构造抽象语法树<br>- 处理错误                                                                               |
| [19：并发](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/19-concurrency/)                                  | - 两种并发编程模型<br>- 进程、线程、时间切片<br>- 示例：共享内存<br>- 交织<br>- 竞争条件<br>- 调整代码无济于事<br>- 重组<br>- 示例：消息传递<br>- 并发性难以测试和调试                                                 |
| [20：螺纹安全](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/20-thread-safety/)                              | - 线程安全意味着什么<br>- 策略一：坐月子<br>- 策略二：不变性<br>- 策略 3：使用线程安全数据类型<br>- 如何提出安全论据                                                                                     |
| [21：套接字和网络](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/21-sockets-networking/)                       | - 客户端/服务器设计模式<br>- 网络套接字<br>- I/O<br>- 阻塞<br>- 使用网络套接字<br>- 有线协议<br>- 测试客户端/服务器代码                                                                            |
| [22：队列和消息传递](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/22-queues/)                                  | - 两种并发模型<br>- 使用线程传递消息<br>- 使用队列实现消息传递<br>- 停止<br>- 具有消息传递的线程安全参数                                                                                            |
| [23：锁定和同步](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/23-locks/)                                     | - 同步<br>- 僵局<br>- 开发 ThreadSafe 抽象数据类型<br>- 锁定<br>- 监视模式<br>- 具有同步的线程安全参数<br>- 原子作<br>- 设计并发的数据类型<br>- 僵局抬起丑陋的头<br>- 并行程序设计的目标<br>- 并发实践                     |
| [24：图形用户界面](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/24-graphical-user-interfaces/)                | - 视图树<br>- 如何使用视图树<br>- 输入处理<br>- 将前端与后端分开<br>- 图形用户界面中的后台处理                                                                                                 |
| [25：映射、过滤、缩减](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/25-map-filter-reduce/)                      | - 抽象出控制流<br>- 地图<br>- 函数作为值<br>- 滤波器<br>- 减少<br>- 抽象控制的好处<br>- Java 中的一流函数<br>- Java 中的映射/过滤/减少<br>- Java 中的高阶函数                                             |
| [26：小语言](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/26-little-languages/)                            | - 将代码表示为数据<br>- 构建语言来解决问题<br>- 音乐语言                                                                                                                          |
| [27：团队版本控制](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/27-team-version-control/)                     | - Git 工作流<br>- 查看提交历史记录<br>- 提交图<br>- 以团队形式使用版本控制                                                                                                            |
