#### 今天课程的目标
今天的课程有两个主题：
- 静态类型
- 好软件的三大属性
## 数列 Hailstone Sequence
作为一个运行示例，我们将探索冰雹序列，其定义如下。从数字 n 开始，如果 n 为偶数，则序列中的下一个数字为 n/2，如果 n 为奇数，则序列中的下一个数字为 3n+1。当序列达到 1 时，序列结束。这里有些例子：
```

2, 1

3, 10, 5, 16, 8, 4, 2, 1

4, 2, 1

2ⁿ, 2ⁿ⁻¹, ..., 4, 2, 1 `

5, 16, 8, 4, 2, 1

7, 22, 11, 34, 17, 52, 26, 13, 40, ...? `(where does this stop?)

```
由于奇数规则，数列可能会上下波动，然后减至 1。据推测，所有冰雹最终都会落到地上——即，所有开始的 n 个冰雹序列都达到 1——但这仍然是一个[悬而未决的问题](https://en.wikipedia.org/wiki/Collatz_conjecture) 。为什么叫冰雹序列？因为冰雹通过上下弹跳在云中形成，直到它们最终产生足够的重量落到地上。

## 计算冰雹 Computing Hailstones
以下是一些用于计算和打印某些起始 n 的冰雹序列的代码。我们将并排编写 Java 和 Python 代码以便比较：

| `// Java`<br>`int n = 3;`<br>`while (n != 1) {`<br>    `System.out.println(n);`<br>    `if (n % 2 == 0) {`<br>        `n = n / 2;`<br>    `} else {`<br>        `n = 3 * n + 1;`<br>    `}`<br>`}`<br>`System.out.println(n);` | `# Python`<br>`n = 3`<br>`while n != 1:`<br>    `print n`<br>    `if n % 2 == 0:`<br>        `n = n / 2`<br>    `else:`<br>        `n = 3 * n + 1`<br><br><br>`print n` |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
这里有几点值得注意：
- Java 中表达式和语句的基本语义与 Python 非常相似：例如，行为相同。 `while` `if`
- Java 要求在语句末尾使用分号。额外的标点符号可能会很痛苦，但它也让您在组织代码方面拥有更多自由——您可以将语句拆分为多行以提高可读性。
- Java 要求在 `and` 和 `or` 的条件周围使用括号。 `if` `while`
- Java 需要在代码块周围使用大括号，而不是缩进。 你应该始终缩进代码块，即使 Java 不会注意您的额外空格。编程是一种交流形式，你不仅是在与编译器交流，也是在与人交流。人类需要这种缩进。我们稍后会回到这一点。
## 类型 Types
上面的 Python 和 Java 代码之间最重要的语义差异是变量的声明，它指定了变量的类型：。 `n` `int`
类型是一组值，以及可以在这些值上执行的操作。。
Java 有几种**原始类型** ，其中：
- `int` （用于整数如 5 和-200，但限制在±2^31 的范围内，或大致±20 亿）
- `long` （用于更大的整数，范围到±2^63）
- `boolean` （用于 true 或 false）
- `double` （用于浮点数，浮点数表示实数的一个子集集）
- `char` （用于单个字符，如 `'A'` `'$'` )

Java 也有**对象类型** ，例如：
- `String` 表示一个字符序列，类似于 Python 字符串。
- `BigInteger` 表示任意大小的整数，因此它表现得像 Python 中的整数。

根据 Java 约定，原始类型为小写，而对象类型以大写字母开头。

操作是接受输入并产生输出（有时还会改变自身值）的函数。操作的语法可能有所不同，但无论它们如何编写，我们仍然将它们视为函数。以下是 Python 或 Java 中操作的三个不同语法示例：
- **作为中缀、前缀或后缀运算符。** 例如：a + b，其中 "+" 是一个中缀运算符，它的类型是 int × int → int（即两个整数相加得到另一个整数）。
- **作为对象的方法。** 例如：bigint1.add(bigint2)，这里 add 是 BigInteger 类的一个方法，它作用于两个 BigInteger 对象，返回另一个 BigInteger 对象。
- **作为函数（通常是一个静态方法，不依赖于对象实例，而是属于一个类）。** 例如：Math.sin(theta)，这里 sin 是一个函数，它接受一个 double 类型的参数，返回一个 double 类型的值。注意，Math 是一个类，而不是一个对象。我们直接通过类名调用这个函数（静态方法）。`
对比 Java 的 `str.length()`与 Python的 `len(str)`.两种语言中的操作相同——一个接受字符串并返回其长度的函数——但它们使用不同的语法。

某些操作是重载(overloaded)的，指的是同一个操作名称被用于不同的类型。在Java中，算术运算符 `+`、`-`、`*`、`/` 针对数值基本数据类型(primitive types)被大量重载。方法也可以被重载。大多数编程语言都在一定程度上支持重载。 
## 静态类型 Static Typing

Java 是一种**静态类型语言** 。所有变量的类型在编译时（程序运行之前）都是已知的，因此编译器也可以推断出所有表达式的类型。如果 `a`和 `b` 被声明为`int` s，那么编译器得出结论，`a+b`也是一个 `int`。事实上，Eclipse 环境在您编写代码时会执行此作，因此您在键入时会发现许多错误。    

在 Python 等**动态类型语言**中，这种检查被推迟到运行时（当程序运行时）。

静态类型是一种特殊的**静态检查** ，这意味着在编译时检查错误。错误是编程的祸根。本课程中的许多想法旨在消除代码中的错误，而静态检查是我们看到的第一个想法。静态类型可以防止大量错误感染您的程序：准确地说，是由于将作应用于错误类型的参数而引起的错误。如果您编写一行断行代码，例如：
```
   "5" * "6"
```
尝试将两个字符串相乘，则静态类型将在您仍在编程时捕获此错误，而不是等到在执行过程中到达该行。
## 静态检查、动态检查、无检查 Static Checking, Dynamic Checking, No Checking
考虑一种语言可以提供的三种自动检查是有用的：
- **静态检查** ：在程序运行之前就会自动发现错误。
- **动态检查** ：执行代码时自动发现错误。
- **无检查** ：该语言根本无法帮助您找到错误。你必须自己注意，否则最终会得到错误的答案。
不用说，静态捕捉错误总比动态捕捉好，动态捕捉总比根本不捕捉好。

以下是一些经验法则，说明您在每次这些时间可能会发现哪些错误。
**静态检查**可以捕获：
- 语法错误，比如多余的标点符号或无意义的单词。即使是动态类型的语言如 Python 也会进行这种静态检查。如果你的 Python 程序存在缩进错误，你会在程序开始运行之前发现它。
- 错误的名称，例如 `Math.sine(2)`.（正确的名称是 `sin`）
- 错误的参数数量，例如 . `Math.sin(30, 20)`
- 错误的参数类型，例如 . `Math.sin("30")`
- 错误的返回类型，例如`return "30";`从被声明返回int的函数中返回了字符串

**动态检查**可以捕获：
- 非法参数值。例如，`x/y`整数表达式仅  `y`实际为零时才错误;否则它有效。所以在这个表达式中，除以零不是静态误差，而是动态误差。
- 无法表示的返回值，即特定返回值无法在类型中表示。。
- 超出范围的索引，例如在字符串上使用负数或过大的索引。
- 在`null`对象引用上调用方法（ `null` 类似于 Python的`None` ）。  

静态检查通常与类型有关，错误与变量具体的值无关。类型是一组值。静态类型确保变量将具有该集合中的某个值，但我们直到运行时才知道它具体具有哪个值。因此，如果错误仅由特定值引起，例如除零或索引超出范围，那么编译器不会对此产生静态错误。

动态检查则倾向于处理由特定值引起的错误。

## 惊喜：基本类型并非真正的数字 Surprise: Primitive Types Are Not True Numbers

Java（以及许多其他编程语言）中的一个陷阱是，其基本数值类型存在一些边缘情况，这些情况的行为与我们所熟悉的整数和实数不同。因此，一些本应通过动态检查来发现错误的情况，实际上根本不会被检查。以下是陷阱：

- **整数除法** 。 `5/2`不会返回分数，而是返回一个截断的整数。因此，这是一个例子，说明我们原本可能希望这是一个动态错误（因为分数不能表示为整数）的情况，却经常产生错误的结果。 
- 
- **整数溢出** 。`int`和 `long`类型实际上是有限整数集合，具有最大值和最小值。当您进行的计算答案太正或太负而无法适应该有限范围时会发生什么？算会静默地溢出（回绕），并返回合法范围内的一个整数，但不是正确答案。 
- 
- **`float` 和 `doubles` 中的特殊值** 。`float`和`double`类型有几个不是实际数字的特殊值：`NaN`（表示“非数字”）、`POSITIVE_INFINITY`和 `NEGATIVE_INFINITY` 。你期望产生动态错误的操作，如除以零或对负数开平方，反而会产生这些特殊值之一。如果你继续用这个值计算，你最终会得到一个糟糕的最终答案。    

## 数组和集合  Arrays and Collections

让我们更改我们的冰雹序列的计算方式，让它将序列存储在数据结构中，而不是仅仅打印出来。Java 有两种类似列表的类型我们可以使用：arrays 和 Lists。

数组是另一种类型 T 的固定长度序列。例如，以下是声明数组变量并构造一个数组值来赋给它的方法：

```
  int[] a = new int[100];
```

`int[]`数组类型包括所有可能的数组值，但特定数组值一旦创建，就永远无法更改其长度。对数组类型的作包括： 

- 索引： `a[2]`
- 分配： `a[2]=0`
- length： （请注意，这与 – 不是方法调用的语法不同，因此不要在它后面放括号） `a.length` `String.length()` `a.length`

这是使用数组破解冰雹代码的破解。我们首先构造数组，然后使用索引变量单步执行数组，在生成序列时存储序列的值。 `i`

```
int[] a = new int[100];  // <==== DANGER WILL ROBINSON
int i = 0;
int n = 3;
while (n != 1) {
    a[i] = n;
    i++;  // very common shorthand for i=i+1
    if (n % 2 == 0) {
        n = n / 2;
    } else {
        n = 3 * n + 1;
    }
}
a[i] = n;
i++;
```

在这种方法中应该立即闻到一些不对劲的味道。那个神奇的数字 100 是什么？如果我们尝试一个 n 结果显示有一个很长的冰雹序列，会发生什么？它不适合长度为 100 的数组。我们有一个错误。Java 会静态、动态地捕获错误还是根本不捕获错误？顺便说一句，像这样的错误——溢出固定长度数组，通常用于不太安全的语言，如 C 和 C++，它们不对数组访问进行自动运行时检查——已经导致了大量的网络安全漏洞和互联网蠕虫。

让我们使用类型来代替固定长度数组。列表是另一种类型的可变长度序列。以下是我们如何声明变量并创建列表值： `List` `T` `List`

```
  List<Integer> list = new ArrayList<Integer>();
```

以下是它的一些作：

- 索引： `list.get(2)`
- 分配： `list.set(2, 0)`
- 长度： `list.size()`

请注意，这是一个接口，一种不能直接用 new 构造的类型，而是指定 List 必须提供的作。我们将在以后的抽象数据类型课程中讨论这个概念。是一个类，一个提供这些作实现的具体类型。不是 List 类型的唯一实现，尽管它是最常用的实现。是另一个。在 Java API 文档中查看它们，您可以通过在 Web 上搜索“Java 8 API”来找到它。了解 Java API 文档，它们是您的朋友。（“API”的意思是“应用程序程序员接口”，通常用作“库”的同义词。 `List` `ArrayList` `ArrayList` `LinkedList`

另请注意，我们写的不是 .不幸的是，我们不能直接模拟 .列表只知道如何处理对象类型，而不知道原始类型。在 Java 中，每个原始类型（以小写形式编写，通常缩写，例如 ）都有一个等效的对象类型（大写，并且完全拼写，例如 ）。Java 要求我们在参数化带有尖括号的类型时使用这些对象类型的等效项。但在其他上下文中，Java 会自动在 和 之间进行转换，因此我们可以在没有任何类型错误的情况下进行编写。 `List<Integer>` `List<int>` `List<int>` `int[]` `int` `Integer` `int` `Integer` `Integer i = 5`

这是用 Lists 编写的冰雹代码：

```java
List<Integer> list = new ArrayList<Integer>();
int n = 3;
while (n != 1) {
    list.add(n);
    if (n % 2 == 0) {
        n = n / 2;
    } else {
        n = 3 * n + 1;
    }
}
list.add(n);
```

不仅更简单，而且更安全，因为列表会自动放大自身，以适应您添加到其中的数字（当然，直到您用完内存）。

## 迭 代

for 循环遍历数组或列表的元素，就像在 Python 中一样，尽管语法看起来略有不同。例如：

```
// find the maximum point of a hailstone sequence stored in list
int max = 0;
for (int x : list) {
    max = Math.max(x, max);
}
```

您可以循环访问数组和列表。如果列表被数组替换，则相同的代码将起作用。

`Math.max()` 是 Java API 中的一个方便的函数。该课程充满了这样的有用功能——在网络上搜索“java 8 Math”以查找其文档。 `Math`

## 方法

在 Java 中，语句通常必须位于方法中，并且每个方法都必须位于一个类中，因此编写 hailstone 程序的最简单方法如下所示：

```java
public class Hailstone {
  /**
   * Compute a hailstone sequence.
   * @param n  Starting number for sequence.  Assumes n > 0.
   * @return hailstone sequence starting with n and ending with 1.
   */
  public static List<Integer> hailstoneSequence(int n) {
    List<Integer> list = new ArrayList<Integer>();
    while (n != 1) {
        list.add(n);
        if (n % 2 == 0) {
            n = n / 2;
        } else {
            n = 3 * n + 1;
        }
    }
    list.add(n);
    return list;
  }
}
```

让我们在这里解释一些新事物。

`public` 意味着程序中任何位置的任何代码都可以引用类或方法。其他访问修饰符（如 private）用于在程序中获得更高的安全性，并保证不可变类型的不可变性。我们将在即将到来的课程中更多地讨论它们。

`static` 意味着该方法不接受 self 参数——无论如何，这在 Java 中是隐式的，你永远不会将其视为方法参数。无法在对象上调用静态方法。例如，将其与方法或方法进行对比，这些方法或方法需要一个对象放在第一位。相反，调用静态方法的正确方法是使用类名而不是对象引用： `List` `add()` `String` `length()`

```java
  Hailstone.hailstoneSequence(83)
```

还要注意方法之前的注释，因为它非常重要。此注释是该方法的规范，描述了作的输入和输出。规范应简洁明了、准确。注释提供的方法类型中尚不清楚的信息。例如，它没有说这是一个整数，因为下面的声明已经说了。但它确实说必须是肯定的，这不是类型声明捕获的，但对于调用者来说非常重要。 `n` `int n` `n`

关于如何在几堂课中编写好的规范，我们将有很多话要说，但您必须立即开始阅读和使用它们。

## 改变值与重新分配变量

下一篇阅读将介绍_快照图_，为我们提供一种可视化更改变量和更改值之间区别的方法。当您赋值给变量时，您正在更改变量的箭头指向的位置。您可以将其指向不同的值。

当您赋值到可变值（例如数组或列表）的内容时，您正在更改该值内的引用。

变化是一种必要的罪恶。好的程序员会避免改变的事情，因为它们可能会出乎意料地改变。

不变性（对更改的免疫）是本课程的一个主要设计原则。不可变类型是其值一旦创建就永远无法更改的类型。（至少不是以一种对外界可见的方式——其中有一些微妙之处，我们将在以后的关于不变性的课程中更多地讨论。到目前为止，我们讨论的哪些类型是不可变的，哪些是可变的？

Java 还为我们提供了不可变的引用：分配一次且永不重新分配的变量。要使引用不可变，请使用关键字 final 声明它：

```
  final int n = 5;
```

如果 Java 编译器不相信您的最终变量在运行时只会被赋值一次，那么它将产生编译器错误。因此，final 为您提供了对不可变引用的静态检查。

最好使用 final 来声明方法的参数和尽可能多的局部变量。与变量的类型一样，这些声明是重要的文档，对代码的读者有用，并由编译器进行静态检查。

我们的 hailstoneSequence 方法中有两个变量：我们可以声明它们是否可以声明它们最终？

```
  public static List<Integer> hailstoneSequence(final int n) { 
    final List<Integer> list = new ArrayList<Integer>();
```

## 记录假设

写下变量的类型记录了一个关于它的假设：例如，这个变量将始终引用一个整数。Java 实际上在编译时检查了这个假设，并保证你的程序中没有一个地方违反了这个假设。

声明变量 final 也是一种文档形式，声称变量在初始赋值后永远不会改变。Java 也会静态地检查这一点。

我们记录了另一个假设，即 Java（不幸的是）不会自动检查：n 必须是正数。

为什么我们需要写下我们的假设？因为编程里到处都是，如果我们不写下来，我们就不会记住它们，而以后需要阅读或更改我们程序的其他人也不会知道它们。他们必须猜测。

编写程序时必须牢记两个目标：

- 与计算机通信。首先说服编译器你的程序是合理的——语法正确且类型正确。然后正确处理逻辑，以便在运行时给出正确的结果。
- 与他人交流。使程序易于理解，以便将来有人必须修复、改进或调整它时，他们可以这样做。

## 黑客与工程

我们在这个课程中编写了一些黑客代码。黑客攻击通常以肆无忌惮的乐观为标志：

- 坏：在测试任何代码之前编写大量代码
- 坏：把所有的细节都记在脑海里，假设你会永远记住它们，而不是把它们写在代码里
- 坏：假设错误不存在，否则很容易找到和修复

但软件工程不是黑客攻击。工程师是悲观主义者：

- 好：一次写一点，边做边测试。在以后的课程中，我们将讨论测试优先编程。
- 良好：记录代码所依赖的假设
- 好：保护你的代码免受愚蠢的侵害——尤其是你自己的代码！静态检查对此有所帮助。

## 目标 6.005

我们本课程的主要目标是学习如何制作以下软件：

- **免受虫子侵害** 。正确性（现在的正确行为）和防御性（未来的正确行为）。
- **易于理解** 。必须与需要理解它并对其进行更改（修复错误或添加新功能）的未来程序员进行沟通。未来的程序员可能是几个月或几年后的你。如果你不把它写下来，你会惊讶地发现你会忘记多少，以及拥有一个好的设计对你未来的自己有多大帮助。
- 准备好**改变** 。软件总是在变化。有些设计可以轻松进行更改;其他的则需要丢弃和重写大量代码。

软件还有其他重要属性（如性能、可用性、安全性），它们可能会与这三者进行权衡。但这些是我们在 6.005 中关心的三巨头，软件开发人员通常在构建软件的实践中放在首位。值得考虑我们在本课程中学习的每一种语言特性、每一种编程实践、每一种设计模式，并了解它们与三巨头的关系。

## 为什么我们在本课程中使用 Java

由于您已经使用了 6.01，因此我们假设您对 Python 感到满意。那么为什么我们不在本课程中使用 Python 呢？为什么我们在 6.005 中使用 Java？

**安全**是第一原因。Java 具有静态检查（主要是类型检查，但也有其他类型的静态检查，例如您的代码从声明这样做的方法返回值）。我们在本课程中学习的是软件工程，防止错误是该方法的一个关键原则。Java 将安全性调至 11，这使其成为学习良好软件工程实践的良好语言。使用 Python 等动态语言编写安全代码当然是可能的，但如果您学习使用安全的、经过静态检查的语言，则更容易理解您需要做什么。

无**处不在是**另一个原因。Java 广泛应用于研究、教育和工业领域。Java 在许多平台上运行，而不仅仅是 Windows/Mac/Linux。Java 可用于 Web 编程（在服务器和客户端上），原生 Android 编程是用 Java 完成的。尽管其他编程语言更适合教授编程（我想到了 Scheme 和 ML），但遗憾的是，这些语言在现实世界中并不那么普遍。简历上的 Java 将被认为是一项适销对路的技能。但不要误会我们的意思：您将从本课程中获得的真正技能不是特定于 Java，而是延续到您可能编程的任何语言中。本课程中最重要的课程将在语言时尚中幸存下来：安全性、清晰度、抽象性、工程本能。

无论如何，一个好的程序员必须是 **多语言** .编程语言是工具，您必须使用正确的工具来完成这项工作。在完成麻省理工学院的职业生涯之前，您肯定必须学习其他编程语言（JavaScript、C/C++、Scheme 或 Ruby、ML 或 Haskell），因此我们现在从学习第二种语言开始。

由于它无处不在，Java 拥有大量有趣和有用的**库** （包括其庞大的内置库和网上的其他库），以及出色的免费开发**工具**（Eclipse 等 IDE、编辑器、编译器、测试框架、分析器、代码覆盖率、样式检查器）。即使是 Python 在其生态系统的丰富性方面仍然落后于 Java。

有一些原因后悔使用 Java。它很冗长，这使得很难在黑板上写例子。它很大，多年来积累了许多功能。它在内部是不一致的（例如，关键字在不同的上下文中表示不同的东西，并且 Java 中的关键字与静态检查无关）。它与 C/C++ 等旧语言的包袱相加权（原始类型和语句就是很好的例子）。它没有像 Python 那样的解释器，您可以通过玩少量代码来学习。 `final` `static` `switch`

但总的来说，Java 是目前学习如何编写不受错误影响、易于理解并准备好更改的代码的合理语言选择。这就是我们的目标。

## 总结

我们今天介绍的主要思想是**静态检查** 。以下是这个想法与课程目标的关系：

- **免受虫子的影响。** 静态检查通过在运行时之前捕获类型错误和其他错误来帮助提高安全性。
    
- **易于理解。** 它有助于理解，因为类型在代码中显式说明。
    
- 准备好**改变。** 静态检查通过识别需要同时更改的其他位置，可以更轻松地更改代码。例如，当您更改变量的名称或类型时，编译器会立即在使用该变量的所有位置显示错误，并提醒您也更新它们。